% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitP2G_ls.R
\name{fitP2G_ls}
\alias{fitP2G_ls}
\title{Conversion of Graded Response Items to Generalized Partial Credit Items}
\usage{
fitP2G_ls(
  paramG,
  theta = NULL,
  init = 1,
  paramP = NULL,
  method = 0,
  wtype = 1,
  wmean = 0,
  wsd = 1,
  DinP = 1,
  npoints = 21,
  thmin = -3,
  thmax = 3,
  printGN = 0,
  maxiter = 500,
  eps = 0.000001,
  epsg = 0.000001,
  epsx = 0.000000001,
  print = 1,
  plot = 0
)
}
\arguments{
\item{paramG}{Item Parameter Data Frame with item types: \cr
"Bn","B3","Bn3","G","Gn"}

\item{theta}{Vector of theta points}

\item{init}{= 1 to use fitP2G, else use equally spaced b-parameters}

\item{paramP}{initial parameter data frame.
This has priority over \code{init}.}

\item{method}{= 0 to use icrf to calculate rmse (default) \cr
= 1 to use item info to calculate rmse, \cr
= 2 to use item category info* to calculate rmse}

\item{wtype}{= 0 not to use dnorm(theta) as the weight}

\item{wmean}{The mean of normal distribution to be used as the weight}

\item{wsd}{The sd of normal distribution to be used as the weight}

\item{DinP}{= 1 to include D=1.7 in logistic function}

\item{npoints}{# of discrete points for theta}

\item{thmin}{Minimum value of discrete theta value}

\item{thmax}{Maximum value of discrete theta value}

\item{printGN}{print level for lazy.mat::GN function}

\item{maxiter}{Maximum # of GN iterations}

\item{eps}{Convergence criterion for the relative improvement of rmse}

\item{epsg}{Convergence crit for the maximum absolute value of the gradient}

\item{epsx}{Convergence crit for the maximum absolute change of
the parameter value}

\item{print}{>= 1 to print result}

\item{plot}{>= 1 to plot result}
}
\value{
A list of: \cr
paramNew: Fitted GPCM item parameter data frame \cr
 2PLM or 2PNM items remain unchaged. \cr
paramG: Input GRM item parameter data frame \cr
grad: Gradient matrix \cr
wtype, wmean, wsd, method, init \cr
rmse_p: rmse in terms of icrf (method=0)\cr
rmse_ii: rmse in terms of item information (method=1)\cr
rmse_iic: rmse in terms of item category information* (method=2)\cr
icrfNew, icifNew, iifNew \cr
icrfOld, icifOld, iifOld
}
\description{
Conversion of Graded Response Items to Generalized Partial Credit Items
}
\details{
This function finds the set of GPCM item paramters
which best fit the given icrfs or item info functions of the items
in the input parameter data frame. \cr\cr

If method = 0, this function minimizes\cr
\code{ sum( w*( vec(icrf(theta)) - vec(icrf_GPCM(theta|PARAM)) )^2 ) } \cr
with respect to the GPCM item parameters, PARAM, \cr
where \code{icrf(theta)} is the icrf of the input items, \cr
 \code{icrf_GPCM(theta|PARAM)} is the icrf of the fitted GPCM items, \cr
and \code{w} is the weight vector ( \code{N(wmean,wsd^2)} or 1 ). \cr

If method = 1, this function minimizes\cr
\code{ sum( w*( info_i(theta) - info_i_GPCM(theta|PARAM) )^2 ) } \cr
with respect to the GPCM item parameters, PARAM, \cr
where \code{info_i(theta)} is the item information function
 of input items and \cr
 \code{info_i_GPCM(theta|PARAM)} is the item information function of
 the fitted GPCM items. \cr

If method = 2, this function minimizes\cr
\code{ sum( w*( vec(info_ic(theta)) - vec(info_ic_GPCM(theta|PARAM)) )^2 ) }
 \cr
with respect to the GPCM item parameters, PARAM, \cr
where \code{info_ic(theta)} is the item category information function
 of input items and \cr
 \code{info_ic_GPCM(theta|PARAM)} is the item category information function
 of the fitted GPCM items. \cr

\cr
When three parameter binary items are included, 2PLM will be fitted.
\cr
Weighted Gauss-Newton method (\code{lazy.mat::GN}) is used for
the minimization with the numerical
Jacobian matrix calculated by \code{lazy.mat::JacobianMat}.
\cr
}
\examples{
paramP1 <- fitP2G_ls( paramS2, plot=1, print=1 )$paramNew
paramG1 <- fitGn2P_ls( paramP1, plot=1, print=1 )

# convert 3PLM and GPCM items
param <- paramA1[c(2,5,8),]
theta <- seq(-4,4,length=51)

# maxiter below is too small!!
res0 <- fitP2G_ls( param, theta, maxiter=20, plot=1, wtype=1, method=0 )
res1 <- fitP2G_ls( param, theta, maxiter=20, plot=1, wtype=1, method=1 )
res2 <- fitP2G_ls( param, theta, maxiter=3, plot=1, wtype=1, method=2 )

Print(res0$rmse_p, res0$rmse_iic, res0$rmse_ii)
Print(res1$rmse_p, res1$rmse_iic, res1$rmse_ii)
Print(res2$rmse_p, res2$rmse_iic, res2$rmse_ii)


}
