% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coseq.R
\name{coseq}
\alias{coseq}
\title{Classical Observed Score Equating}
\usage{
coseq(
  score1,
  freq1,
  cdf1 = NULL,
  score2,
  freq2,
  cdf2 = NULL,
  lim1 = NULL,
  lim2 = NULL,
  smooth1 = 0,
  bandwid1 = 3,
  smooth2 = 0,
  bandwid2 = 3,
  method = 2,
  interpol_method = "linear",
  title = "",
  nolow = 0,
  print = 1,
  plot = 1
)
}
\arguments{
\item{score1}{a vector consisting of the score of test1}

\item{freq1}{a vector consisting of the frequency counts at score1}

\item{cdf1}{a vector consisting of the cumulative frequencies at score1}

\item{score2}{a vector consisting of the score of test2}

\item{freq2}{a vector consisting of the frequency counts at score2}

\item{cdf2}{a vector consisting of the cumulative frequencies at score2}

\item{lim1}{min and max score of test1}

\item{lim2}{min and max score of test2}

\item{smooth1}{# of times to smooth cdf1}

\item{bandwid1}{bandwidth for running average smooth of cdf1}

\item{smooth2}{# of times to smooth cdf2}

\item{bandwid2}{bandwidth for running average smooth of cdf2}

\item{method}{= 1 to use linear equating \cr
= 2 to use equipercentile equating}

\item{interpol_method}{= "constant", "linear" or "spline"}

\item{title}{title string}

\item{nolow}{= 1 to avoid lowering scores}

\item{print}{= 1 to print the result}

\item{plot}{= 1 to plot the conversion table \cr
= 2 to plot the cdf \cr
= 3 to plot the smoothed cdf}
}
\value{
a list of the following:\cr
ctable0: the conversion table consisting of (score, score21, freq1) \cr
ctable: the conversion table to the rounded score. \cr
mands:  the summary stat of the converted score dist: (score21,freq1) \cr
newfreq: the frequency distribution of the converted score (score21, freq21)
\cr
sdist1 and sdist2: input and smoothed score distributions \cr
cntr: a list of control parameters used.

\code{ctable} shows that
test score score1[i] of test1 is equivalent to
test score score21[i] of test2.
}
\description{
This performs the observed score equating of
the test score 1 to the test score 2.\cr
Japanese help file: (\link[lazy.irt]{coseq_JPH})
}
\details{
Equipercentile equating of test1 score \code{x1} to test2 score \code{x2}
 is defined as\cr
\preformatted{
 x21 = invF2( F1(x1) )
}
where \code{F1} is the distribution function of \code{x1} and
\code{invF2} is the inverse of the distribution function of \code{x2}.
In this function, \code{invF2} is calculated by interpolating
\code{( F2(x2), x2 )} at \code{F1(x1)} with or without smoothing.

Equipercentile equating is essentially the same as native \code{qqplot}. \cr
Therefore, the following two codes produce similar results: \cr
\preformatted{
 eq( score1=score1, freq1=freq1, score2=score2, freq2=freq2 )
 qqplot( expand_freqdist( score1, freq1 )
             , expand_freqdist( score2, freq2 ), type="l" )
}
Note that, since native \code{qqplot} cannot handle case weight,
\code{lazy.tools::expand_freqdist} is used to recover the raw data
from frequency table.


\code{cdf} has priority over \code{freq}.
}
\examples{

set.seed(1701)

x1 <- round( 10*rbeta(500,2,4) )
f1 <- table(x1)
x1 <- as.numeric(names(f1))
x2 <- round( 15*rbeta(1000,4,2) )
f2 <- table(x2)
x2 <- as.numeric(names(f2))

reseq <- coseq( score1=x1, freq1=f1, score2=x2, freq2=f2
                , lim1=c(0,10), lim2=c(0,15)
                , smooth1=3, smooth2=3, method=2, plot=0 )

}
